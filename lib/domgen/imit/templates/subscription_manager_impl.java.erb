/* DO NOT EDIT: File is auto-generated */
package <%= repository.imit.entity_package %>;

import org.realityforge.replicant.client.transport.SubscriptionEntry;

@javax.annotation.Generated( "Domgen" )
@java.lang.SuppressWarnings( { "UnusedDeclaration", "JavaDoc" } )
public class <%= repository.imit.subscription_manager_impl_name %>
  extends org.realityforge.replicant.client.transport.AbstractSubscriptionManager<<%= repository.imit.qualified_graph_enum_name %>>
  implements <%= repository.imit.qualified_subscription_manager_name %>
{
  private static final java.util.logging.Logger LOG = java.util.logging.Logger.getLogger( <%= repository.imit.subscription_manager_impl_name %>.class.getName() );

  private final <%= repository.imit.qualified_client_session_context_name %> _context;

  public <%= repository.imit.subscription_manager_impl_name %>( final <%= repository.imit.qualified_client_session_context_name %> context )
  {
    _context = context;
  }
<%
  repository.imit.graphs.each do |graph|
  param = ''
  param_value = ''
  param_early_value = ''
  param_cache_value = ''
  subscribe_method = 'Type'
  if graph.instance_root?
    # Names are fully qualified so take any random data module
    entity = repository.data_modules[0].entity_by_name(graph.instance_root)
    type = entity.primary_key.imit.primitive_java_type
    param = "#{type} id"
    param_value = ', id'
    param_early_value = 'id, '
    subscribe_method = 'Instance'
  elsif graph.cacheable?
    param_cache_value = 'eTag, cacheCurrentAction, '
  end
%>
  public void subscribeTo<%= graph.key %>(<%= param %>)
  {
    final SubscriptionEntry<<%= repository.imit.qualified_graph_enum_name %>> entry =
      subscribeTo<%= subscribe_method %>Graph( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.key) %><%= param_value %> );
    if( null != entry )
    {
      final Runnable runnable = new Runnable()
      {
        @Override
        public void run()
        {
          entry.markAsPresent();
        }
      };
<% if graph.cacheable? -%>
      final org.realityforge.replicant.client.transport.CacheEntry cacheEntry = _context.getCacheService().lookup( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.key) %>.name() );
      final String eTag = null != cacheEntry ? cacheEntry.getETag() : null;
      final String content = null != cacheEntry ? cacheEntry.getContent() : null;
      if( null != content )
      {
        LOG.info( "Found locally cached data for graph <%= graph.key %> with etag " + eTag + "." );
      }
      final Runnable cacheCurrentAction = new Runnable()
      {
        public void run()
        {
          assert null != content;
          LOG.info( "Loading cached data for graph <%= graph.key %> with etag " + eTag );
          //TODO: Figure out how to make the bulkLoad configurable
          _context.loadCachedContent( content, runnable, true );
        }
      };
<% end -%>
      _context.remoteSubscribeTo<%= graph.key %>( <%= param_cache_value %><%= param_early_value %>runnable );
    }
  }

  public void unsubscribeFrom<%= graph.key %>(<%= param %>)
  {
    final SubscriptionEntry<<%= repository.imit.qualified_graph_enum_name %>> entry =
      unsubscribeFrom<%= subscribe_method %>Graph( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.key) %><%= param_value %> );
    if( null != entry )
    {
      entry.markDeregisterInProgress();
      _context.remoteUnsubscribeFrom<%= graph.key %>( <%= param_early_value %>new Runnable()
      {
        @Override
        public void run()
        {
          entry.markAsDeregistered();
        }
      } );
    }
  }
<% end %>
}
