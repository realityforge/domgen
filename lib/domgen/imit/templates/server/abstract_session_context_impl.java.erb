/* DO NOT EDIT: File is auto-generated */
package <%= to_package(repository.imit.qualified_abstract_session_context_impl_name) %>;
<%
# Collect all graph links that we automatically follow
auto_follow_graph_links =
  repository.
    imit.
    graphs.
    select{|g| g.instance_root? }.
    collect{|g| g.inward_graph_links.select{|graph_link| graph_link.auto?} }.
    flatten.
    select do |graph_link|
      target_graph = repository.imit.graph_by_name(graph_link.target_graph)
      target_graph.filter_parameter? && target_graph.instance_root? && repository.imit.graph_by_name(graph_link.source_graph).instance_root?
    end

# Collect list of graphs that we propagate filters from
graphs_that_propagate_filters =
  repository.
    imit.
    graphs.
    select{|graph| graph.unfiltered? || (graph.filter_parameter? && !graph.filter_parameter.immutable?) }.
    select{|graph| graph.outward_graph_links.any?{|graph_link| graph_link.auto? && repository.imit.graph_by_name(graph_link.target_graph).filter_parameter?} }
-%>

/**
 * Subclass this class using the following conventions.
 *
 * <pre>{@code
   @ApplicationScoped
   @Transactional
   @Typed( replicant.server.transport.ReplicantSessionContext.class )
   class <%= repository.imit.session_context_impl_name %>
     extends <%= repository.imit.abstract_session_context_impl_name %>
   {
   ...
   }
  }</pre>
 */
@java.lang.SuppressWarnings( { "SqlNoDataSourceInspection", "DataFlowIssue" } )
public abstract class <%= repository.imit.abstract_session_context_impl_name %>
  extends replicant.server.ee.AbstractSessionContextImpl
  implements replicant.server.transport.ReplicantSessionContext
{
<%
  repository.imit.graphs.select{|graph|graph.filtered?}.each do |graph|
    graph.routing_keys.each do |routing_key|
-%>
  @javax.annotation.Nonnull
  private static final String <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY = "<%= repository.name %>.<%= graph.name %>.<%= routing_key.name %>";
<%
    end
  end

entities =
  auto_follow_graph_links.collect{|graph_link|repository.entity_by_name(repository.imit.graph_by_name(graph_link.target_graph).instance_root)}

entities.uniq.sort_by{|e|e.qualified_name}.each do |entity| -%>
  @javax.inject.Inject
  private <%= entity.dao.jpa.qualified_dao_service_name %> _<%= Reality::Naming.camelize("#{entity.data_module.name}#{entity.name}") %>Repository;
<% end -%>
  @javax.persistence.PersistenceContext( unitName = <%= repository.jpa.qualified_unit_descriptor_name %>.NAME )
  private javax.persistence.EntityManager _entityManager;
<% if repository.imit.secured? -%>
  @javax.annotation.Nonnull
  private final org.keycloak.adapters.KeycloakConfigResolver _resolver = new <%= repository.imit.keycloak_client.qualified_keycloak_config_resolver_name %>();
<% end -%>

  @javax.annotation.Nonnull
  java.lang.SecurityException createNotPermittedException( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final String action )
  {
    return new java.lang.SecurityException( "User does not have required permission to perform action: " + action );
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  public replicant.server.transport.SchemaMetaData getSchemaMetaData()
  {
    return iris.rose.server.net.RoseMetaData.getSchemaMetaData();
  }

  @Override
  public boolean isAuthorized( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session )
  {
<% if repository.imit.secured? -%>
    return null != toAccessToken( session );
<% else -%>
    return true;
<% end -%>
  }
<% if repository.imit.secured? -%>

  @javax.annotation.Nullable
  org.keycloak.representations.AccessToken toAccessToken( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session )
  {
    final var authToken = session.getAuthToken();
    if ( null == authToken )
    {
      return null;
    }
    else
    {
      try
      {
        return org.keycloak.adapters.rotation.AdapterTokenVerifier.verifyToken( authToken, _resolver.resolve( null ) );
      }
      catch ( final org.keycloak.common.VerificationException ve )
      {
        return null;
      }
    }
  }
<% end -%>

  @java.lang.Override
  public void preSubscribe( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final replicant.server.ChannelAddress address, @javax.annotation.Nullable final Object filter )
  {
<%
  first = true
-%>
<% repository.imit.graphs.select{|graph|graph.secure? && graph.external_visibility?}.each do |graph| -%>
    <%= first ? '' : 'else ' %>if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %> == address.channelId() )
    {
<% if graph.filter_parameter -%>
      final var <%= Reality::Naming.camelize("#{graph.name}Filter") %> = (<%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %>) filter;
      assert null != <%= Reality::Naming.camelize("#{graph.name}Filter") %>;
<% end -%>
      ensureSubscribeTo<%= graph.name %>Permitted( session, address<% if graph.filter_parameter -%>, <%= Reality::Naming.camelize("#{graph.name}Filter") %><% end -%> );
    }
<%
    first = false
  end
-%>
  }
<% instanced_graphs = repository.imit.graphs.select{|graph|graph.instanced?} -%>
<% if instanced_graphs.any? -%>

  @javax.annotation.Nonnull
  @java.lang.Override
  public String deriveFilterInstanceId( @javax.annotation.Nonnull final replicant.server.EntityMessage entityMessage, @javax.annotation.Nonnull final replicant.server.ChannelLink link, @javax.annotation.Nullable final java.lang.Object sourceFilter, @javax.annotation.Nullable final java.lang.Object targetFilter )
  {
   <% instanced_graphs.select{|graph|graph.instance_root?}.each do |graph| -%> if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %> == link.target().channelId() )
    {
<% graph.inward_graph_links.select{|graph_link| graph_link.auto?}.each do |graph_link| -%>
     <% instanced_graphs.each do |graph| -%> if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph_link.source_graph) %> == link.source().channelId() )
      {
<% source_graph = repository.imit.graph_by_name(graph_link.source_graph) -%>
<% if source_graph.filter_parameter -%>
        final var <%=Reality::Naming.camelize(source_graph.name) %>Filter = (<%= Domgen::Java.java_type(source_graph.filter_parameter, :ee, :default) %>) sourceFilter;
        assert null != <%=Reality::Naming.camelize(source_graph.name) %>Filter;
<% end -%>
<% target_graph = repository.imit.graph_by_name(graph_link.target_graph) -%>
        final var <%=Reality::Naming.camelize(target_graph.name) %>Filter = (<%= Domgen::Java.java_type(target_graph.filter_parameter, :ee, :default) %>) targetFilter;
        assert null != <%=Reality::Naming.camelize(target_graph.name) %>Filter;
        return deriveFilterInstanceIdForLinkFrom_<%= graph_link.source_graph %>_To_<%= graph_link.target_graph %>_Via_<%= graph_link.imit_attribute.attribute.qualified_name.gsub(/[#.]/,'_') %>( entityMessage, link<% if source_graph.filter_parameter -%>, <%=Reality::Naming.camelize(source_graph.name) %>Filter<% end %>, <%=Reality::Naming.camelize(target_graph.name) %>Filter );
      }
      else<% end -%>

      {
        return super.deriveFilterInstanceId( entityMessage, link, sourceFilter, targetFilter );
      }
<% end -%>
    }
    else<% end -%>

    {
      return super.deriveFilterInstanceId( entityMessage, link, sourceFilter, targetFilter );
    }
  }
<% instanced_graphs.each do |graph| -%>
<% if graph.instance_root? -%>
<% graph.inward_graph_links.select{|graph_link| graph_link.auto?}.each do |graph_link| -%>
<%
     source_graph = repository.imit.graph_by_name(graph_link.source_graph)
     target_graph = repository.imit.graph_by_name(graph_link.target_graph)
     source_graph_instanced = source_graph.instanced?
-%>

  @javax.annotation.Nonnull
  protected<%= source_graph_instanced ? '' : ' abstract' %> String deriveFilterInstanceIdForLinkFrom_<%= graph_link.source_graph %>_To_<%= graph_link.target_graph %>_Via_<%= graph_link.imit_attribute.attribute.qualified_name.gsub(/[#.]/,'_') %>( @javax.annotation.Nonnull final replicant.server.EntityMessage <%= Reality::Naming.camelize(graph_link.imit_attribute.attribute.name) %>EntityMessage, @javax.annotation.Nonnull final replicant.server.ChannelLink link<% if source_graph.filter_parameter -%>, @javax.annotation.Nullable final <%= Domgen::Java.java_type(source_graph.filter_parameter, :ee, :default) %> <%=Reality::Naming.camelize(source_graph.name) %>Filter<% end -%>, @javax.annotation.Nonnull final <%= Domgen::Java.java_type(target_graph.filter_parameter, :ee, :default) %> <%=Reality::Naming.camelize(target_graph.name) %>Filter )<%= source_graph_instanced ? '' : ';' %>
<% if source_graph_instanced -%>
  {
    final var <%=Reality::Naming.camelize(source_graph.name) %>FilterInstanceId = link.source().filterInstanceId();
    assert null != <%=Reality::Naming.camelize(source_graph.name) %>FilterInstanceId;
    final var <%=Reality::Naming.camelize(target_graph.name) %>RootId = link.target().rootId();
    return <%=Reality::Naming.camelize(source_graph.name) %>FilterInstanceId + "~" + <%=Reality::Naming.camelize(target_graph.name) %>RootId;
  }
<% end -%>
<% end -%>
<% end -%>
<% end -%>
<% end -%>

  @javax.annotation.Nonnull
  @java.lang.Override
  public Object deriveTargetFilter( @javax.annotation.Nonnull final replicant.server.EntityMessage entityMessage, @javax.annotation.Nonnull final replicant.server.ChannelAddress source, @javax.annotation.Nullable final java.lang.Object sourceFilter, @javax.annotation.Nonnull final replicant.server.ChannelAddress target )
  {
<% if !auto_follow_graph_links.any? -%>
    return super.deriveTargetFilter( entityMessage, source, sourceFilter, target );
<% else -%>
<%
  first = true
  auto_follow_graph_links.each do |graph_link|
    target_graph = repository.imit.graph_by_name(graph_link.target_graph)
    source_graph = repository.imit.graph_by_name(graph_link.source_graph)
-%>
<% if first -%>   <% end -%> if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(source_graph.name) %> == source.channelId() )
    {
<% if source_graph.filter_parameter -%>
      final var sourceGraphFilter = (<%= Domgen::Java.java_type(source_graph.filter_parameter, :ee, :default) %>) sourceFilter;
      assert null != sourceGraphFilter;
<% end -%>
      return deriveTargetFilterFrom<%= source_graph.name %>To<%= target_graph.name %>( entityMessage, source<% if source_graph.filter_parameter? %>, sourceGraphFilter<% end %> );
    }
    else<% end %>
    {
      return super.deriveTargetFilter( entityMessage, source, sourceFilter, target );
    }
<% end -%>
  }
<%
  auto_follow_graph_links.each do |graph_link|
    target_graph = repository.imit.graph_by_name(graph_link.target_graph)
    source_graph = repository.imit.graph_by_name(graph_link.source_graph)
-%>

  @javax.annotation.Nonnull
  abstract <%= Domgen::Java.java_type(target_graph.filter_parameter, :ee, :default) %> deriveTargetFilterFrom<%= source_graph.name %>To<%= target_graph.name %>( @javax.annotation.Nonnull final replicant.server.EntityMessage entityMessage, @javax.annotation.Nonnull final replicant.server.ChannelAddress source<% if source_graph.filter_parameter? %>, @javax.annotation.Nonnull <%= Domgen::Java.java_type(source_graph.filter_parameter, :ee, :default) %> sourceGraphFilter<% end %> );
<% end -%>

  @java.lang.SuppressWarnings( "unchecked" )
  @javax.annotation.Nullable
  @java.lang.Override
  public replicant.server.EntityMessage filterEntityMessage( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final replicant.server.ChannelAddress address, @javax.annotation.Nonnull final replicant.server.EntityMessage message )
  {
<% if repository.imit.graphs.select{|graph| graph.filtered?}.empty? -%>
    throw new java.lang.IllegalStateException( "filterEntityMessage called for unfiltered channel " + address );
<% else -%>
<% first = true -%>
<% repository.imit.graphs.select{|graph| graph.filtered?}.each do |graph| -%>
<% if first -%>   <% end -%> if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %> == address.channelId() )
    {
<%
  first = false
  extra_interest_filter = ''
  graph.routing_keys.each do |routing_key|
    var_name = Reality::Naming.camelize("#{graph.name}_#{routing_key.name}")
    extra_interest_filter << ", #{var_name}"
    param_type = routing_key.target_attribute.jpa.non_primitive_java_type
    param_type = "java.util.List<#{param_type}>" if routing_key.multivalued?
-%>
      final var <%= var_name %> = (<%= param_type %>) message.getRoutingKeys().get( <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY );
<% end -%>
<% if graph.instance_root? -%>
      final var rootId = address.rootId();
      assert null != rootId;
<% end -%>
<% if graph.filter_parameter? -%>
      final var filter = (<%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %>) session.getSubscriptionEntry( address ).getFilter();
      assert null != filter;
<% end -%>
      return filterMessageOfInterestIn<%= graph.name %>Graph( message, session<% if graph.instance_root? %>, rootId<% end %><% if graph.filter_parameter? %>, filter<% end %><%= extra_interest_filter %> );
    }
    else<% end %>
    {
      throw new java.lang.IllegalStateException( "filterEntityMessage called for unfiltered channel " + address );
    }
<% end -%>
  }

  @java.lang.Override
  protected void doBulkCollectDataForSubscribe( @javax.annotation.Nullable final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final java.util.List<replicant.server.ChannelAddress> addresses, @javax.annotation.Nullable final Object filter, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, final boolean isExplicitSubscribe )
  {
    final var address = addresses.get( 0 );
    try
    {
<% repository.imit.graphs.each do |graph| -%>
      <%= repository.imit.graphs[0] == graph ? '' : 'else ' %>if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %> == address.channelId() )
      {
<% if graph.filter_parameter -%>
        assert null != filter;
<% end -%>
        doBulkCollectFor<%= graph.name %>( session, changeSet<% if graph.instance_root? %>, addresses<% end %><% if graph.filter_parameter -%>, (<%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %>) filter<% end %>, isExplicitSubscribe );
      }
<% end -%>
      else
      {
        throw new java.lang.IllegalStateException( "bulkCollectDataForSubscribe called for unsupported channel " + address );
      }
    }
    catch ( final java.sql.SQLException sqle )
    {
      throw new java.lang.IllegalStateException( sqle );
    }
  }
<% bulk_subscription_update_graphs = repository.imit.graphs.select{|graph| graph.filtered? && graph.filter_parameter? && !graph.filter_parameter.immutable?} -%>

  @java.lang.Override
  public void bulkCollectDataForSubscriptionUpdate( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final java.util.List<replicant.server.ChannelAddress> addresses, @javax.annotation.Nullable final Object originalFilter, @javax.annotation.Nullable final Object filter, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet )
  {
<% if !bulk_subscription_update_graphs.empty? -%>
    try
    {
<% bulk_subscription_update_graphs.each do |graph| -%>
      <%= bulk_subscription_update_graphs[0] == graph ? '' : 'else ' %>if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %> == addresses.get( 0 ).channelId() )
      {
        assert null != filter;
        assert null != originalFilter;
        bulkCollectFor<%= graph.name %>FilterChange( session, changeSet<% if graph.instance_root? %>, addresses<% end %>, (<%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %>) originalFilter, (<%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %>) filter );
      }
<% end -%>
      else
      {
        throw new java.lang.IllegalStateException( "bulkCollectDataForSubscriptionUpdate called for unknown channel " + addresses.get( 0 ) );
      }
    }
    catch ( final java.sql.SQLException sqle )
    {
      throw new java.lang.IllegalStateException( sqle );
    }
<% else -%>
    throw new java.lang.IllegalStateException( "bulkCollectDataForSubscriptionUpdate called for unknown channel " + addresses.get( 0 ) );
<% end -%>
  }

  @java.lang.Override
  public boolean shouldFollowLink( @javax.annotation.Nonnull final replicant.server.transport.SubscriptionEntry sourceEntry, @javax.annotation.Nonnull final replicant.server.ChannelAddress target, @javax.annotation.Nullable final java.lang.Object filter )
  {
<% if auto_follow_graph_links.any? -%>
    final var source = sourceEntry.address();
    final var sourceChannelId = source.channelId();
    final var targetChannelId = target.channelId();
<% auto_follow_graph_links.each do |graph_link|
         target_graph = repository.imit.graph_by_name(graph_link.target_graph)
         source_graph = repository.imit.graph_by_name(graph_link.source_graph)
         target_graph_instance_root = repository.entity_by_name(target_graph.instance_root)
 -%>
    <%= auto_follow_graph_links[0] == graph_link ? '' : 'else ' %>if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(source_graph.name) %> == sourceChannelId && <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(target_graph.name) %> == targetChannelId )
    {
<% if target_graph.instance_root? -%>
      final var targetRootId = target.rootId();
      assert null != targetRootId;
<% end -%>
<% if source_graph.filter_parameter? -%>
      final var sourceGraphFilter = (<%= Domgen::Java.java_type(source_graph.filter_parameter, :ee, :default) %>) sourceEntry.getFilter();
      assert null != sourceGraphFilter;
<% end -%>
      final var targetGraphInstanceRoot = _<%= Reality::Naming.camelize("#{target_graph_instance_root.data_module.name}#{target_graph_instance_root.name}") %>Repository.getBy<%= target_graph_instance_root.primary_key.name %>( targetRootId );
      return shouldFollowLinkFrom<%= graph_link.source_graph %>To<%= target_graph.name %>( targetGraphInstanceRoot<% if source_graph.filter_parameter? -%>, sourceGraphFilter<% end -%> );
    }
<% end -%>
    else
    {
      throw new java.lang.IllegalStateException( "shouldFollowLink called for link between channel " + sourceEntry.address() + " and " + target + " and the target has no filter or the link is unknown." );
    }
<% else -%>
    throw new java.lang.IllegalStateException( "shouldFollowLink called for link between channel " + sourceEntry.address() + " and " + target + " and the target has no filter or the link is unknown." );
<% end -%>
  }

<%
processed = []
repository.imit.graphs.select { |g| g.instance_root? }.collect { |g| g.inward_graph_links.select { |graph_link| graph_link.auto? } }.flatten.each do |graph_link|
  source_graph = repository.imit.graph_by_name(graph_link.source_graph)
  target_graph = repository.imit.graph_by_name(graph_link.target_graph)
  next unless target_graph.filtered?
  key = "#{graph_link.source_graph}=>#{graph_link.target_graph}"
  next if processed.include?(key)
  processed << key
  target_graph_instance_root = target_graph.instance_root? ? repository.entity_by_name(target_graph.instance_root) : nil
  source_graph_instance_root = repository.entity_by_name(source_graph.instance_root)

  if target_graph.filter_parameter? -%>
  abstract boolean shouldFollowLinkFrom<%= "#{graph_link.source_graph}To#{target_graph.name}" %>(<%= target_graph.instance_root? || source_graph.filter_parameter? ? ' ' : '' %><%= target_graph.instance_root? ? "@javax.annotation.Nonnull #{target_graph_instance_root.jpa.qualified_name} #{target_graph.name}InstanceRoot" : '' %><%= target_graph.instance_root? && source_graph.filter_parameter? ? ', ' : '' %><%= source_graph.filter_parameter? ? "@javax.annotation.Nonnull #{source_graph.filter_parameter.referenced_struct.ee.qualified_name} #{source_graph.name}Filter" : '' %><%= target_graph.instance_root? || source_graph.filter_parameter? ? ' ' : '' %>);

<%
  end
end
-%>
<% repository.imit.graphs.select{|graph|graph.secure? && graph.external_visibility?}.each do |graph| -%>
  void ensureSubscribeTo<%= graph.name %>Permitted(@javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final replicant.server.ChannelAddress address<% if graph.filter_parameter -%>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter<% end %> )
  {
    if ( !isSubscribeTo<%= graph.name %>Permitted( session, address<% if graph.filter_parameter -%>, filter<% end -%> ) )
    {
      throw createNotPermittedException( session, "SubscribeTo<%= graph.name %>" );
    }
  }

  abstract boolean isSubscribeTo<%= graph.name %>Permitted( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final replicant.server.ChannelAddress address<% if graph.filter_parameter -%>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter<% end %> );

<% end -%>
<% repository.imit.graphs.select{|graph|graph.type_graph?}.each do |graph| -%>
  @java.lang.SuppressWarnings( "SameParameterValue" )
  private void doBulkCollectFor<%= graph.name %>( @javax.annotation.Nullable final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet<% if graph.filter_parameter -%>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter<% end %>, final boolean explicitSubscribe )
    throws java.sql.SQLException
  {
    final var address = new replicant.server.ChannelAddress( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %> );
    if ( null != session )
    {
      recordSubscription( session, changeSet, address, <%= graph.filter_parameter ? 'filter' : 'null' %>, explicitSubscribe );
    }
    else
    {
      changeSet.mergeAction( address, replicant.server.ChannelAction.Action.ADD, <% if graph.filter_parameter -%>filter<% else %>null<% end %> );
    }

<% graph.included_entities.collect{|name| repository.entity_by_name(name)}.each do |entity| -%>
    bulkCollectFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %><%= graph.unfiltered? ? '' : 'Filtered' %>TypeGraph( changeSet<% if graph.filter_parameter -%>, filter<% end %> );
<% end -%>
<% if graph.cacheable? -%>
    if ( null == session )
    {
      changeSet.setETag( deriveETagFor<%= graph.name %>TypeGraph( changeSet ) );
    }
<% end -%>
  }
<% if graph.cacheable? -%>

  @javax.annotation.Nonnull
  java.lang.String deriveETagFor<%= graph.name %>TypeGraph( @java.lang.SuppressWarnings( "unused" ) @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet )
  {
    // Could calculate from contents in future but this is good enough for now.
    return java.lang.String.valueOf( java.lang.System.currentTimeMillis() );
  }
<% end -%>

<%
  graph.included_entities.collect{|name| repository.entity_by_name(name)}.each do |entity|
  in_single_graph = 1 == entity.imit.replication_graphs.size
  in_instance_graph = entity.imit.replication_graphs.any?{|g| g.instance_root?}
  has_links = entity.attributes.any?{|a| a.imit? && !a.imit.auto_graph_links.empty?}
  id_key = entity.name.to_s.gsub(/[a-z]/, '')
  require_channelRootIdColumn = has_links || in_instance_graph
  add_default_impl =
    !entity.attributes.filter{|attribute| attribute.imit?}.any?{|attribute| !attribute.imit.auto_graph_links.filter{|graph_link| !graph_link.path.nil? && repository.imit.graph_by_name(graph_link.target_graph).instance_root? && repository.imit.graph_by_name(graph_link.target_graph).instance_root != graph.instance_root}.empty?}

 -%>

  /**
   * Collect data for <%= entity.qualified_name %> that are part of the <%= graph.name %> type graph. Example implementation:
   * <pre>{@code
     @Language("TSQL")
     final var sql = "SELECT <%= id_key %>.* FROM <%= entity.sql.qualified_table_name.gsub('[','').gsub(']','') %> <%= id_key %><%= entity.transaction_time? ? " WHERE #{id_key}.DeletedAt IS NULL" : '' %>";
    try ( var statement = connection().prepareStatement( sql ) )
    {
        encode<%= entity.qualified_name.gsub('.','') %>( changeSet<% unless in_single_graph %>, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %><% end %>, statement<% if require_channelRootIdColumn %>, null<% end %> );
    }
   * }</pre>
   *
   * @param changeSet A non-null {@code ChangeSet} objects representing the changes generated as part of the bulk operation.
   * @throws java.sql.SQLException If a database access error occurs, or the method encounters an issue during the operation.
   */
<% if add_default_impl -%>
  @java.lang.SuppressWarnings( "resource" )
<% end -%>
  <%= add_default_impl ? '' : 'abstract ' %>void bulkCollectFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %><%= graph.unfiltered? ? '' : 'Filtered' %>TypeGraph( @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet<% if graph.filter_parameter -%>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter<% end %> )
    throws java.sql.SQLException<%= add_default_impl ? '' : ';' %>
<% if add_default_impl -%>
  {
    @org.intellij.lang.annotations.Language("TSQL")
    final var sql = "SELECT <%= id_key %>.* FROM <%= entity.sql.qualified_table_name.gsub('[','').gsub(']','') %> <%= id_key %><%= entity.transaction_time? ? " WHERE #{id_key}.DeletedAt IS NULL" : '' %>";
    try ( var statement = connection().prepareStatement( sql ) )
    {
        encode<%= entity.qualified_name.gsub('.','') %>( changeSet<% unless in_single_graph %>, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %><% end %>, statement<% if require_channelRootIdColumn %>, null<% end %> );
    }
  }
<% end -%>

<% end -%>
<% end -%>
<%
repository.imit.graphs.select{|graph| graph.filtered?}.each do |graph|
  extra_params = ''
  extra_args = ''
  mutable_routing_keys = false
  graph.routing_keys.each do |routing_key|
    nullable = !graph.instance_root?||!(routing_key.imit_attribute.attribute.entity.qualified_name==graph.instance_root)
    mutable_routing_keys ||= !routing_key.referenced_attribute.immutable?
    type = Domgen::Java.non_primitive_java_type(routing_key.referenced_attribute, :ee, :boundary)
    type = "java.util.List<#{type}>" if routing_key.multivalued?
    extra_params += ", #{nullability_annotation(nullable)} final #{type} #{Reality::Naming.camelize(routing_key.name)}"
    extra_args += ", #{Reality::Naming.camelize(routing_key.name)}"
  end
  -%>
<% if mutable_routing_keys -%>
  @javax.annotation.Nonnull
  abstract replicant.server.transport.FilterResult test<%= graph.name %>Interesting( @javax.annotation.Nonnull final replicant.server.EntityMessage message, @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session <% if graph.instance_root? %>, @javax.annotation.Nonnull final <% entity = repository.entity_by_name(graph.instance_root) %> <%= entity.primary_key.jpa.non_primitive_java_type %> <%= Reality::Naming.camelize("#{entity.name}#{entity.primary_key.name}") %> <% end %><% if graph.filter_parameter? %>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter <% end %><%= extra_params %> );

  @javax.annotation.Nullable
  private replicant.server.EntityMessage filterMessageOfInterestIn<%= graph.name %>Graph( @javax.annotation.Nonnull final replicant.server.EntityMessage message, @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session <% if graph.instance_root? %>, @javax.annotation.Nonnull final <%entity = repository.entity_by_name(graph.instance_root) %> <%= entity.primary_key.jpa.non_primitive_java_type %> <%= Reality::Naming.camelize("#{entity.name}#{entity.primary_key.name}") %> <% end %><% if graph.filter_parameter? %>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter <% end %><%= extra_params %> )
  {
    final var result = test<%= graph.name %>Interesting( message, session<% if graph.instance_root? %>, <% entity = repository.entity_by_name(graph.instance_root) %> <%= Reality::Naming.camelize("#{entity.name}#{entity.primary_key.name}") %> <% end %><%if graph.filter_parameter? %>, filter <% end %><%= extra_args %> );
    if ( replicant.server.transport.FilterResult.KEEP == result )
    {
      return message;
    }
    else if ( replicant.server.transport.FilterResult.DELETE == result )
    {
      return message.toDelete();
    }
    else
    {
      return null;
    }
  }
<% else -%>
  abstract boolean is<%= graph.name %>Interesting( @javax.annotation.Nonnull final replicant.server.EntityMessage message, @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session <% if graph.instance_root? %>, @javax.annotation.Nonnull final <% entity = repository.entity_by_name(graph.instance_root) %> <%= entity.primary_key.jpa.non_primitive_java_type %> <%= Reality::Naming.camelize("#{entity.name}#{entity.primary_key.name}") %> <% end %><% if graph.filter_parameter? %>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter <% end %><%= extra_params %> );

  @javax.annotation.Nullable
  private replicant.server.EntityMessage filterMessageOfInterestIn<%= graph.name %>Graph( @javax.annotation.Nonnull final replicant.server.EntityMessage message, @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session <% if graph.instance_root? %>, @javax.annotation.Nonnull final <%entity = repository.entity_by_name(graph.instance_root) %> <%= entity.primary_key.jpa.non_primitive_java_type %> <%= Reality::Naming.camelize("#{entity.name}#{entity.primary_key.name}") %> <% end %><% if graph.filter_parameter? %>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter <% end %><%= extra_params %> )
  {
    if ( is<%= graph.name %>Interesting( message, session<% if graph.instance_root? %>, <% entity = repository.entity_by_name(graph.instance_root) %> <%= Reality::Naming.camelize("#{entity.name}#{entity.primary_key.name}") %> <% end %><%if graph.filter_parameter? %>, filter <% end %><%= extra_args %> ) )
    {
      return message;
    }
    else
    {
      return null;
    }
  }
<% end -%>
<% end -%>

  @javax.annotation.Nonnull
  @java.lang.Override
  protected javax.persistence.EntityManager em()
  {
    return _entityManager;
  }

<% repository.imit.graphs.select{|graph|graph.type_graph?}.each do |graph|
     graph.included_entities.collect{|name| repository.entity_by_name(name)}.each do |entity|
       in_single_graph = 1 == entity.imit.replication_graphs.size
       in_instance_graph = entity.imit.replication_graphs.any?{|g| g.instance_root?}
       has_links = entity.attributes.any?{|a| a.imit? && !a.imit.auto_graph_links.empty?}
       require_channelRootIdColumn = has_links || in_instance_graph
-%>

  @java.lang.SuppressWarnings( { "unused", "SameParameterValue" } )
  void addUpdateFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>TypeGraph( @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, @javax.annotation.Nonnull final java.sql.PreparedStatement statement )
    throws java.sql.SQLException
  {
    encode<%= entity.qualified_name.gsub('.','') %>( changeSet<% unless in_single_graph %>, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %><% end %>, statement<% if require_channelRootIdColumn %>, null<% end %> );
  }

  @java.lang.SuppressWarnings( { "resource", "unused", "SqlSourceToSinkFlow", "SameParameterValue" } )
  void addUpdateFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>TypeGraph( @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, @org.intellij.lang.annotations.Language( "TSQL" ) @javax.annotation.Nonnull final java.lang.String sql )
    throws java.sql.SQLException
  {
    try ( var statement = connection().prepareStatement( sql ) )
    {
      addUpdateFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>TypeGraph( changeSet, statement );
    }
  }
<%   end -%>
<% end -%>
<% repository.imit.graphs.select{|graph|graph.instance_root?}.each do |graph|
  instance_root = repository.entity_by_name(graph.instance_root)
  pk_long_name = instance_root.primary_key.qualified_name.gsub('.','')

  graph.included_entities.collect{|name| repository.entity_by_name(name)}.each do |entity|
    in_single_graph = 1 == entity.imit.replication_graphs.size
    id_key = entity.name.to_s.gsub(/[a-z]/, '')
    is_instance = instance_root == entity

    graph_links_to_other_entities = false
    entity.attributes.filter{|attribute| attribute.imit?}.each do |attribute|
      attribute.imit.auto_graph_links.each do |graph_link|
        source_graph = repository.imit.graph_by_name(graph_link.source_graph)
        target_graph = repository.imit.graph_by_name(graph_link.target_graph)
        if source_graph == graph
          if target_graph.instance_root? && target_graph.instance_root != graph.instance_root && !graph_link.path.nil?
            if 'EventShiftsInTimePeriod' == graph.name.to_s
              $stderr.puts( "#{graph.name} graph links from #{attribute.name} target_root #{target_graph.instance_root} instance_root=#{graph.instance_root} #{graph_link.path.inspect}")
            end
            graph_links_to_other_entities = true
          end
        end
      end
    end
    # Set to attribute that references instance root. Best guess at how to achieve root id but may not always work
    instance_root_references =
      entity.attributes.select{|attribute| attribute.imit? && attribute.reference? && attribute.referenced_entity == instance_root}
    instance_root_reference = instance_root_references.size == 1 ? instance_root_references[0] : nil;
    root_id_column = is_instance ? entity.primary_key.name : instance_root_reference ? "#{instance_root_reference.sql.column_name}" : "?#{instance_root.name}#{instance_root.primary_key.sql.column_name}"
    require_root_id_column = !is_instance && instance_root_reference.nil?
    add_default_impl =
       graph.unfiltered? &&
       (is_instance || !instance_root_reference.nil?) &&
       !graph_links_to_other_entities
-%>

  /**
   * Collect data for <%= entity.qualified_name %> that are part of the <%= graph.name %> instance graph. Example implementation:
   * <pre>{@code
     @Language("TSQL")
     final var sql =
         generateTempIdTable( addresses ) +
         "SELECT <%= !require_root_id_column ? '' : "#{root_id_column}, " %><%= id_key %>.* FROM <%= entity.sql.qualified_table_name.gsub('[','').gsub(']','') %> <%= id_key %> JOIN @Ids Inputs ON Inputs.Id = <%= "#{id_key}.#{root_id_column}" %><%= entity.transaction_time? ? " WHERE #{id_key}.DeletedAt IS NULL" : '' %>";
     addUpdateFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>InstanceGraph( changeSet, "<%= is_instance ? "#{instance_root.primary_key.name}" : "#{instance_root.name}#{instance_root.primary_key.name}" %>", sql );
   * }</pre>
   *
   * @param addresses A non-null list of channel addresses that are used to identify the roots of the <%= graph.name %> graph.
   * @param changeSet A non-null {@code ChangeSet} objects representing the changes generated as part of the bulk operation.
   * @throws java.sql.SQLException If a database access error occurs, or the method encounters an issue during the operation.
   */
  <%= add_default_impl ? '' : 'abstract ' %>void bulkCollectFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>Graph( @javax.annotation.Nonnull final java.util.List<replicant.server.ChannelAddress> addresses, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet<% if graph.filter_parameter -%>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter<% end %> )
    throws java.sql.SQLException<%= add_default_impl ? '' : ';' %>
<% if add_default_impl -%>
  {
     @org.intellij.lang.annotations.Language("TSQL")
     final var sql =
         generateTempIdTable( addresses ) +
         "SELECT <%= !require_root_id_column ? '' : "#{root_id_column}, " %><%= id_key %>.* FROM <%= entity.sql.qualified_table_name.gsub('[','').gsub(']','') %> <%= id_key %> JOIN @Ids Inputs ON Inputs.Id = <%= "#{id_key}.#{root_id_column}" %><%= entity.transaction_time? ? " WHERE #{id_key}.DeletedAt IS NULL" : '' %>";
     addUpdateFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>InstanceGraph( changeSet, "<%= root_id_column %>", sql );
  }
<% end -%>

<% if graph.filter_parameter && !graph.filter_parameter.immutable? && entity != instance_root -%>

  abstract void bulkCollectFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>GraphFilterChange( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final java.util.List<replicant.server.ChannelAddress> addresses, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> originalFilter, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter )
    throws java.sql.SQLException;
<% end -%>

  @java.lang.SuppressWarnings( { "unused", "SameParameterValue" } )
  void addUpdateFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>InstanceGraph( @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, @javax.annotation.Nonnull final java.lang.String <%= Reality::Naming.camelize(pk_long_name) %>ColumnName, @javax.annotation.Nonnull final java.sql.PreparedStatement statement )
    throws java.sql.SQLException
  {
    encode<%= entity.qualified_name.gsub('.','') %>( changeSet<% unless in_single_graph %>, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %><% end %>, statement, <%= Reality::Naming.camelize(pk_long_name) %>ColumnName );
  }

  @java.lang.SuppressWarnings( { "resource", "unused", "SqlSourceToSinkFlow", "SameParameterValue" } )
  void addUpdateFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>InstanceGraph( @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, @javax.annotation.Nonnull final java.lang.String <%= Reality::Naming.camelize(pk_long_name) %>ColumnName, @org.intellij.lang.annotations.Language( "TSQL" ) @javax.annotation.Nonnull final java.lang.String sql )
    throws java.sql.SQLException
  {
    try ( var statement = connection().createStatement() )
    {
      encode<%= entity.qualified_name.gsub('.','') %>( changeSet<% unless in_single_graph %>, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %><% end %>, statement.executeQuery( sql ), <%= Reality::Naming.camelize(pk_long_name) %>ColumnName );
    }
  }
<% end -%>

  private void doBulkCollectFor<%= graph.name %>( @javax.annotation.Nullable final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, @javax.annotation.Nonnull final java.util.List<replicant.server.ChannelAddress> input<% if graph.filter_parameter -%>, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter<% end %>, final boolean explicitSubscribe )
    throws java.sql.SQLException
  {
    final var addresses = new java.util.ArrayList<>( input );
    // This block deals with non-existent root entities by sending a DELETE channel action
    // back, which is the behavior expected by the client and implemented in the non-bulk scenario
    addDeleteForInstanceRootIn<%= graph.name %>InstanceGraph( changeSet, addresses );
    // Abort if it turns out all addresses were deleted
    if ( addresses.isEmpty() )
    {
      return;
    }
<% if graph.required_type_graphs.empty? -%>
    if ( null != session )
    {
      recordSubscriptions( session, changeSet, addresses, <%= graph.filter_parameter? ? 'filter' : 'null' -%>, explicitSubscribe );
    }
<% else -%>
<% # The assumption is that these graphs are already scubscribed so that getSubscriptionEntry works -%>
<% graph.required_type_graphs.each do |graph| -%>
    if ( null != session )
    {
      final var <%= Reality::Naming.camelize(graph.name) %>Graph = new replicant.server.ChannelAddress( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %> );
<% end -%>
      for ( final var address : addresses )
      {
        final var sourceEntry = recordSubscription( session, changeSet, address, <%= graph.filter_parameter? ? 'filter' : 'null' -%>, explicitSubscribe );
<% graph.required_type_graphs.each do |graph| -%>
        linkSubscriptionEntries( sourceEntry, session.getSubscriptionEntry( <%= Reality::Naming.camelize(graph.name) %>Graph ) );
<% end -%>
      }
    }
<% end -%>

<% graph.included_entities.collect{|name| repository.entity_by_name(name)}.each do |entity| -%>
    bulkCollectFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>Graph( addresses, changeSet<% if graph.filter_parameter -%>, filter<% end %> );
<% end -%>
  }
<% if graph.filter_parameter && !graph.filter_parameter.immutable? -%>

  private void bulkCollectFor<%= graph.name %>FilterChange( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, @javax.annotation.Nonnull final java.util.List<replicant.server.ChannelAddress> input, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> originalFilter, <%= nullability_annotation(graph.filter_parameter.nullable?) %> final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> filter )
    throws java.sql.SQLException
  {
    final var addresses = new java.util.ArrayList<>( input );
    // This block deals with non-existent root entities by sending a DELETE channel action
    // back which is the behavior expected by the client and implemented in the non-bulk scenario
    addDeleteForInstanceRootIn<%= graph.name %>InstanceGraph( changeSet, addresses );
    // Abort if it turns out all addresses were deleted
    if ( addresses.isEmpty() )
    {
      return;
    }

    // No change on root entity as all we have to do is update the filter
    for ( final var address : addresses )
    {
      changeSet.mergeAction( address, replicant.server.ChannelAction.Action.UPDATE, filter );
      session.getSubscriptionEntry( address ).setFilter( filter );
    }

<%
  graph.filtered_outward_auto_graph_links.each do |graph_link|
     target_graph = repository.imit.graph_by_name(graph_link.target_graph)
-%>
    bulkPropagateFilterFrom<%= graph.name %>To<%= target_graph.name %>( session, addresses, changeSet, filter );
<% end -%>
<% graph.included_entities.select{|name| graph.instance_root != name}.collect{|name| repository.entity_by_name(name)}.each do |entity| -%>
    bulkCollectFor<%= entity.qualified_name.gsub('.','') %>In<%= graph.name %>GraphFilterChange( session, addresses, changeSet, originalFilter, filter );
<% end -%>
  }
<% end -%>

  @java.lang.SuppressWarnings( { "resource", "unused", "SqlSourceToSinkFlow", "SameParameterValue" } )
  void addDeleteForInstanceRootIn<%= graph.name %>InstanceGraph( @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, @javax.annotation.Nonnull final java.util.List<replicant.server.ChannelAddress> addresses )
    throws java.sql.SQLException
  {
    @org.intellij.lang.annotations.Language( "TSQL" )
    final var sql =
      generateTempIdTable( addresses ) +
      "SELECT Inputs.Id\n" +
      "FROM @Ids Inputs\n" +
      "LEFT JOIN <%= repository.entity_by_name(graph.instance_root).sql.qualified_table_name %> E ON E.<%= repository.entity_by_name(graph.instance_root).primary_key.sql.quoted_column_name %> = Inputs.Id\n" +
      "WHERE E.Id IS NULL\n";
    try ( var statement = connection().createStatement( ) )
    {
      try ( var resultSet = statement.executeQuery( sql ) )
      {
        while ( resultSet.next() )
        {
          final var id = resultSet.getInt( "Id" );
          final var address = new replicant.server.ChannelAddress( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %>, id );
          changeSet.mergeAction( address, replicant.server.ChannelAction.Action.DELETE, null );
          final var removed = addresses.remove( address );
          assert removed;
        }
      }
    }
  }
<% end -%>
<% if repository.imit.graphs.any?{|graph| graph.filter_parameter? && !graph.filter_parameter.immutable? && !graph.outward_graph_links.empty? && graph.outward_graph_links.any?{|graph_link| graph_link.auto? && repository.imit.graph_by_name(graph_link.target_graph).filtered?} } -%>
<% repository.imit.graphs.select{|graph| graph.filter_parameter? && !graph.filter_parameter.immutable? }.each do |graph|
  root_type = graph.instance_root? ? Domgen::Java.java_type(repository.entity_by_name(graph.instance_root).primary_key, :ee, :default) : nil
  processed = []
  graph.filtered_outward_auto_graph_links.each do |graph_link|
     target_graph = repository.imit.graph_by_name(graph_link.target_graph)
     source_graph_instance_root = repository.entity_by_name(graph.instance_root)
     parameters_equiv = graph.filter_parameter? && target_graph.filter_parameter.equiv?(graph.filter_parameter)
-%>

  abstract void bulkPropagateFilterFrom<%= graph.name %>To<%= target_graph.name %>( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final java.util.List<replicant.server.ChannelAddress> addresses, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet, @javax.annotation.Nonnull final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default)%> <%= Reality::Naming.camelize("#{graph.name}Filter") %> )
    throws java.sql.SQLException;

  void propagateFilterFrom<%= graph.name %>To<%= target_graph.name %>( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet<% if graph.filtered? %>, @javax.annotation.Nonnull final <%= Domgen::Java.java_type(target_graph.filter_parameter, :ee, :default)%> <%= Reality::Naming.camelize("#{target_graph.name}Filter") %><% end %>, @org.intellij.lang.annotations.Language( "TSQL" ) @javax.annotation.Nonnull final java.lang.String sql, @java.lang.SuppressWarnings( "SameParameterValue" ) @javax.annotation.Nonnull final java.lang.String <%= Reality::Naming.camelize("#{target_graph.name}IdColumnName") %> )
    throws java.sql.SQLException
  {
    final var targets = getChannelAddressesForTargetGraph( sql, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(target_graph.name) %>, <%= Reality::Naming.camelize("#{target_graph.name}IdColumnName") %> );
    for ( final var entry : this.<<%= Domgen::Java.java_type(target_graph.filter_parameter, :ee, :default)%>>partitionGraphsByFilter( session, targets ).entrySet() )
    {
      bulkCollectFor<%= target_graph.name %>FilterChange( session, changeSet, entry.getValue(), entry.getKey(), <%= Reality::Naming.camelize("#{target_graph.name}Filter") %> );
    }
  }
<% if parameters_equiv -%>

  @javax.annotation.Nonnull
  <%= Domgen::Java.java_type(target_graph.filter_parameter, :ee, :default) %> deriveFilterToPropagateFrom<%= graph.name %>To<%= target_graph.name %>( <% if graph.instance_root? -%>@java.lang.SuppressWarnings( "unused" ) @javax.annotation.Nonnull final <%= source_graph_instance_root.jpa.qualified_name %> sourceGraphInstanceRoot<% end %><% if graph.filtered? %><%= graph.instance_root? ? ', ' : '' %>@javax.annotation.Nonnull final <%= Domgen::Java.java_type(graph.filter_parameter, :ee, :default) %> <%= Reality::Naming.camelize("#{graph.name}Filter") %><% end %> )<%= parameters_equiv ? '' : ';' %>
  {
    return <%= Reality::Naming.camelize("#{graph.name}Filter") %>;
  }
<% end -%>
<% end -%>
<% end -%>

  @java.lang.SuppressWarnings( "unchecked" )
  @javax.annotation.Nonnull
  private <T> java.util.Map<T, java.util.List<replicant.server.ChannelAddress>> partitionGraphsByFilter( @javax.annotation.Nonnull final replicant.server.transport.ReplicantSession session, @javax.annotation.Nonnull final java.util.Set<replicant.server.ChannelAddress> targets )
  {
    final var map = new java.util.HashMap<T, java.util.List<replicant.server.ChannelAddress>>();
    for ( final var target : targets )
    {
      final var filter = (T) session.getSubscriptionEntry( target ).getFilter();
      map.computeIfAbsent( filter, e -> new java.util.ArrayList<>() ).add( target );
    }
    return map;
  }

  @java.lang.SuppressWarnings( { "SameParameterValue", "resource" } )
  @javax.annotation.Nonnull
  private java.util.Set<replicant.server.ChannelAddress> getChannelAddressesForTargetGraph( @org.intellij.lang.annotations.Language( "TSQL" ) @javax.annotation.Nonnull final String sql, final int targetGraph, @javax.annotation.Nonnull final String targetGraphColumnName )
    throws java.sql.SQLException
  {
    final var targets = new java.util.HashSet<replicant.server.ChannelAddress>();
    try ( var statement = connection().createStatement() )
    {
      try ( var resultSet = statement.executeQuery( sql ) )
      {
        while ( resultSet.next() )
        {
          targets.add( new replicant.server.ChannelAddress( targetGraph, resultSet.getInt( targetGraphColumnName ) ) );
        }
      }
    }
    return targets;
  }
<% end -%>
  @java.lang.SuppressWarnings( "DataFlowIssue" )
  @javax.annotation.Nullable
  protected replicant.server.EntityMessage convertToEntityMessage( @javax.annotation.Nonnull final Object object, final boolean isUpdate, final boolean isInitialLoad )
  {
   <%
repository.data_modules.select { |data_module| data_module.imit? }.each do |data_module|
  data_module.entities.each do |entity|
    if entity.imit? && entity.concrete?
-%> if( object instanceof <%= entity.jpa.qualified_name %> entity<% if entity.jpa.track_changes? -%> && ( isInitialLoad || !isUpdate || !entity.unmodified() )<% end -%> )
    {
      return convert<%= data_module.name %><%= entity.name %>ToEntityMessage( entity, isUpdate );
    }
    else<%
    end
  end
end
%>
    {
      return null;
    }
  }
<%
repository.data_modules.select { |data_module| data_module.imit? }.each do |data_module|
  data_module.entities.each do |entity|
    if entity.imit? && entity.concrete?

      links = entity.attributes.collect{|a| a.imit? ? a.imit.auto_graph_links : [] }.flatten -%>

  @javax.annotation.Nonnull
  private replicant.server.EntityMessage convert<%= data_module.name %><%= entity.name %>ToEntityMessage( @javax.annotation.Nonnull final <%= entity.jpa.qualified_name %> entity, final boolean isUpdate )
  {
<% if links.size > 0 -%>
    @javax.annotation.Nullable final var attributes = isUpdate <% if entity.transaction_time? -%>&& null == entity.getDeletedAt() <% end -%>? encode<%= entity.name %>( entity ) : null;
    @javax.annotation.Nonnull final var routingKeys = route<%= entity.name %>( entity );
    @javax.annotation.Nonnull final java.util.Set<replicant.server.ChannelLink> links = new java.util.HashSet<>();
    if( null != attributes )
    {
<%
  links.each do |graph_link|
    source_graph = repository.imit.graph_by_name(graph_link.source_graph)
    target_graph = repository.imit.graph_by_name(graph_link.target_graph)
    rentity = graph_link.imit_attribute.attribute.primary_key? ? graph_link.imit_attribute.attribute.entity : graph_link.imit_attribute.attribute.referenced_entity
    attribute_getter_path = getter_for(graph_link.imit_attribute.attribute)
    getter_path = graph_link.imit_attribute.attribute.reference? ? [attribute_getter_path] : []
    last_getter_nullable = false
    if graph_link.path
      last_getter_nullable = graph_link.imit_attribute.attribute.nullable?
      graph_link.path.to_s.split.each do |attribute_name_path_element|
        other = rentity.attribute_by_name(attribute_name_path_element)
        last_getter_nullable = other.nullable?
        getter_path << getter_for(other)
        rentity = other.referenced_entity
      end
    end
    nullcheck_required = graph_link.imit_attribute.attribute.nullable? || last_getter_nullable
-%>
<% if source_graph.instance_root? -%>
      addChannelLinks( routingKeys, links, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(source_graph.name) %>, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(source_graph.name) %>_NAME, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(target_graph.name) %>, <% if graph_link.imit_attribute.attribute.nullable? -%>null == entity.<%= getter_for(graph_link.imit_attribute.attribute)%> <% end %><% if graph_link.imit_attribute.attribute.nullable? && last_getter_nullable %>|| <% end %><% if last_getter_nullable %>null == entity.<%= getter_path.join('.') %> <% end -%><% if nullcheck_required -%>? null : <% end -%>entity.<%= (getter_path + [getter_for(rentity.primary_key)]).join('.') %> );
<% else -%>
      addChannelLink( links, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(source_graph.name) %>, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(target_graph.name) %>, <% if graph_link.imit_attribute.attribute.nullable? -%>null ==  entity.<%= getter_for(graph_link.imit_attribute.attribute)%> <% if last_getter_nullable %>|| null == entity.<%= getter_path.join('.') %> <% end -%> ? null : <% end -%>entity.<%= (getter_path + [getter_for(rentity.primary_key)]).join('.') %> );
<% end -%>
<% end -%>
<% end -%>
<% if links.size > 0 -%>
    }
<% end -%>
    return new replicant.server.EntityMessage( entity.<%= getter_for(entity.primary_key) %>, <%= repository.imit.qualified_entity_type_constants_name %>.<%= Reality::Naming.uppercase_constantize(entity.data_module.name.to_s) %>_<%= Reality::Naming.uppercase_constantize(entity.name.to_s) %>, System.currentTimeMillis(), <% if links.size > 0 %>routingKeys<% else %>route<%= entity.name %>( entity )<% end %>, <% if links.size > 0 %>attributes<% else %>isUpdate <% if entity.transaction_time? -%>&& null == entity.getDeletedAt() <% end -%>? encode<%= entity.name %>( entity ) : null<% end %>, <%= links.size == 0 ? 'null' : 'links' %> );
  }
<%
    end
  end
end
-%>
<%
  repository.imit.graphs.select{|graph|graph.filtered?}.each do |graph|
    graph.routing_keys.each do |routing_key|
      unless routing_key.target_nullsafe?
        index = 0
        a = routing_key.imit_attribute.attribute
        e = a.reference? ? a.referenced_entity : a.entity
        is_inverse = routing_key.inverse_start?
        routing_key.path.each do |path_element|
          next_is_inverse = routing_key.is_inverse_path_element?(path_element)
          n = routing_key.get_attribute_name_from_path_element?(path_element)
          next_attribute =
            next_is_inverse ?
            a.entity.arez.referencing_client_side_attributes.select {|attr| attr.inverse.name.to_s == n.to_s}[0] :
            e.attribute_by_name(n)
-%>

  private void route_<%= graph.name %>_<%= routing_key.name %>_<%= index %>( @javax.annotation.Nonnull final java.util.Map<String, java.io.Serializable> map, <%= nullability_annotation(a.nullable?) %> final <%= (is_inverse ? a.entity : a.referenced_entity).jpa.qualified_name %> value )
  {
<% if a.nullable? -%>
    if( null != value )
    {
<% end -%>
<% if routing_key.is_path_element_recursive?(path_element) -%>
    route_<%= graph.name %>_<%= routing_key.name %>_<%= index + 1 %>( map, value );
    route_<%= graph.name %>_<%= routing_key.name %>_<%= index %>( map, value.<%= getter_for(next_attribute) %> );
<% elsif next_is_inverse -%>
    for( final var v : value.get<%= next_attribute.inverse.multiplicity == :many ? Reality::Naming.pluralize(next_attribute.inverse.name) : next_attribute.inverse.name %>() )
    {
      route_<%= graph.name %>_<%= routing_key.name %>_<%= index + 1 %>( map, v );
    }
<% else -%>
    route_<%= graph.name %>_<%= routing_key.name %>_<%= index + 1 %>( map, value.<%= getter_for(next_attribute) %> );
<% end -%>
<% if a.nullable? -%>
    }
<% end -%>
  }
<%
          a = next_attribute
          e = a.entity
          is_inverse = next_is_inverse
          index = index + 1
        end
-%>

  private void route_<%= graph.name %>_<%= routing_key.name %>_<%= index %>( @javax.annotation.Nonnull final java.util.Map<String, java.io.Serializable> map, <%= nullability_annotation(a.nullable?) %> final <%= (is_inverse ? a.entity : a.referenced_entity).jpa.qualified_name %> value )
  {
<% if a.nullable? -%>
    if( null != value )
    {
<% end -%>
<% attr = (is_inverse ? a.entity : a.referenced_entity).attribute_by_name(routing_key.attribute_name) -%>
<% if routing_key.multivalued? -%>
    addInstanceRootRouterKey( map, <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, value.<%= getter_for(attr) %> );
<% else -%>
    map.put( <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, value.<%= getter_for(attr) %> );
<% end -%>
<% if a.nullable? -%>
    }
<% end -%>
  }
<%
      end
    end
  end
-%>
<%
# graph => entity
routes_to_keep = {}
repository.data_modules.select { |data_module| data_module.imit? }.each do |data_module|
  data_module.entities.select { |entity| entity.imit? && entity.concrete? }.each do |entity|
    entity.imit.replication_graphs.each do |graph|
      entity.attributes.select {|a| a.reference? &&
        a.arez? &&
        a.inverse.traversable? &&
        a.referenced_entity.arez? &&
        graph.instance_root? &&
        a.referenced_entity.imit.replication_graphs.include?(graph) &&
        a.imit.graph_links.all?{|g| g.always_follow? || g.source_graph.to_s != graph.name.to_s}}.
       each do |a|
        (routes_to_keep[graph] ||= []) << a.referenced_entity
      end
    end
  end
end
 -%>
<%
repository.data_modules.select { |data_module| data_module.imit? }.each do |data_module|
  data_module.entities.select { |entity| entity.imit? && entity.concrete? }.each do |entity|
    outgoing_links = entity.attributes.select {|a| a.reference? && a.arez? && a.inverse.traversable? && a.referenced_entity.arez?}
 -%>

  @javax.annotation.Nonnull
  private java.util.Map<String, java.io.Serializable> route<%= entity.name %>( @java.lang.SuppressWarnings( "unused" ) @javax.annotation.Nonnull final <%= entity.jpa.qualified_name %> entity )
  {
    final var map = new java.util.HashMap<String, java.io.Serializable>();
<% entity.imit.replication_graphs.each do |graph| -%>
<% if (routes_to_keep[graph] ||= []).include?(entity) -%>
    _route<%= graph.name %>_<%= entity.name %>( map, entity );
<% else -%>
<% if graph.filtered? -%>
<%
  graph.routing_keys.select{|rk| rk.imit_attribute.attribute.entity.name == entity.name}.each do |routing_key|
    initial_attr = routing_key.imit_attribute.attribute
    if !routing_key.reference?
-%>
<% if routing_key.multivalued? -%>
    addInstanceRootRouterKey( map, <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, entity<% unless initial_attr.primary_key? %>.<%= getter_for(initial_attr) %><% end %> );
<% else -%>
    map.put( <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, entity<% unless initial_attr.primary_key? %>.<%= getter_for(initial_attr) %><% end %> );
<% end -%>
<% elsif routing_key.target_nullsafe?
    a = initial_attr
    v = ''
    path = initial_attr.primary_key? ? ['entity'] : ["entity.#{getter_for(a)}"]
    v = "#{path.join('.')} == null ? null : " if a.nullable?
    routing_key.path.each do |path_element|
      a = a.referenced_entity.attribute_by_name(routing_key.get_attribute_name_from_path_element?(path_element))
      path << getter_for(a)
      if a.nullable?
        v = "#{v}#{path.join('.')} == null ? null : "
      end
    end
    path << getter_for(a.referenced_entity.attribute_by_name(routing_key.attribute_name))
    v = "#{v}#{path.join('.')}"
-%>
<% if routing_key.multivalued? -%>
    addInstanceRootRouterKey( map, <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, <%= v %> );
<% else -%>
    map.put( <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, <%= v %> );
<% end -%>
<% else -%>
    route_<%= graph.name %>_<%= routing_key.name %>_0( map, entity<% unless initial_attr.primary_key? %>.<%= getter_for(initial_attr) %><% end %> );
<% end -%>
<% end -%>
<% end -%>
<% if graph.instance_root? && graph.instance_root.to_s == entity.qualified_name.to_s -%>
    addInstanceRootRouterKey( map, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %>_NAME, entity.<%= getter_for(entity.primary_key) %> );
<% elsif graph.instance_root? -%>
<% outgoing_links.select{|a| a.referenced_entity.imit.replication_graphs.include?(graph) && a.imit.graph_links.all?{|g| g.always_follow? || g.source_graph.to_s != graph.name.to_s } }.each do |outgoing_link| -%>
<% if outgoing_link.nullable? -%>
    {
      final var v = entity.<%= getter_for(outgoing_link) %>;
      if( null != v )
      {
        _route<%= graph.name %>_<%= outgoing_link.referenced_entity.name %>( map, v );
      }
    }
<% else -%>
    _route<%= graph.name %>_<%= outgoing_link.referenced_entity.name %>( map, entity.<%= getter_for(outgoing_link) %> );
<% end -%>
<% end -%>
<% else -%>
    map.put( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %>_NAME, Boolean.TRUE );
<% end -%>
<% end -%>
<% end -%>
    return map;
  }
<% entity.imit.replication_graphs.select{|graph| (routes_to_keep[graph] ||= []).include?(entity)}.each do |graph| -%>

  private void _route<%= graph.name %>_<%= entity.name %>( @javax.annotation.Nonnull final java.util.Map<String, java.io.Serializable> map, @javax.annotation.Nonnull final <%= entity.jpa.qualified_name %> entity )
  {
<% if graph.filtered? -%>
<%
  graph.routing_keys.select{|rk| rk.imit_attribute.attribute.entity.name == entity.name}.each do |routing_key|
    initial_attr = routing_key.imit_attribute.attribute
    if !routing_key.reference?
-%>
<% if routing_key.multivalued? -%>
    addInstanceRootRouterKey( map, <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, entity<% unless initial_attr.primary_key? %>.<%= getter_for(initial_attr) %><% end %> );
<% else -%>
    map.put( <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, entity<% unless initial_attr.primary_key? %>.<%= getter_for(initial_attr) %><% end %> );
<% end -%>
<% elsif routing_key.target_nullsafe?
    a = initial_attr
    v = ''
    path = initial_attr.primary_key? ? ['entity'] : ["entity.#{getter_for(a)}"]
    v = "#{path.join('.')} == null ? null : " if a.nullable?
    routing_key.path.each do |path_element|
      a = a.referenced_entity.attribute_by_name(routing_key.get_attribute_name_from_path_element?(path_element))
      path << getter_for(a)
      if a.nullable?
        v = "#{v}#{path.join('.')} == null ? null : "
      end
    end
    path << getter_for(a.referenced_entity.attribute_by_name(routing_key.attribute_name))
    v = "#{v}#{path.join('.')}"
-%>
<% if routing_key.multivalued? -%>
    addInstanceRootRouterKey( map, <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, <%= v %> );
<% else -%>
    map.put( <%= Reality::Naming.uppercase_constantize(graph.name) %>_<%= Reality::Naming.uppercase_constantize(routing_key.name) %>_KEY, <%= v %> );
<% end -%>
<% else -%>
    route_<%= graph.name %>_<%= routing_key.name %>_0( map, entity<% unless initial_attr.primary_key? %>.<%= getter_for(initial_attr) %><% end %> );
<% end -%>
<% end -%>
<% end -%>
<% if graph.instance_root? && graph.instance_root.to_s == entity.qualified_name.to_s -%>
    addInstanceRootRouterKey( map, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %>_NAME, entity.<%= getter_for(entity.primary_key) %> );
<% elsif graph.instance_root? -%>
<% outgoing_links.select{|a| a.referenced_entity.imit.replication_graphs.include?(graph) && a.imit.graph_links.all?{|g| g.always_follow? || g.source_graph.to_s != graph.name.to_s } }.each do |outgoing_link| -%>
<% if outgoing_link.nullable? -%>
    {
      final var v = entity.<%= getter_for(outgoing_link) %>;
      if( null != v )
      {
        _route<%= graph.name %>_<%= outgoing_link.referenced_entity.name %>( map, v );
      }
    }
<% else -%>
    _route<%= graph.name %>_<%= outgoing_link.referenced_entity.name %>( map, entity.<%= getter_for(outgoing_link) %> );
<% end -%>
<% end -%>
<% else -%>
    map.put( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph.name) %>_NAME, Boolean.TRUE );
<% end -%>
  }
<% end -%>
<% end -%>
<% end -%>
<%
repository.data_modules.select { |data_module| data_module.imit? }.each do |data_module|
  data_module.entities.each do |entity|
    if entity.imit? && entity.concrete?
      has_links = entity.attributes.any?{|a| a.imit? && !a.imit.auto_graph_links.empty?}
      in_instance_graph = entity.imit.replication_graphs.any?{|g| g.instance_root?}
      in_type_graph = entity.imit.replication_graphs.any?{|g| g.type_graph?}
      in_single_graph = 1 == entity.imit.replication_graphs.size
      require_channelRootIdColumn = has_links || in_instance_graph
      channelId = in_single_graph ? "#{repository.imit.qualified_subscription_constants_name}.#{Reality::Naming.uppercase_constantize(entity.imit.replication_graphs[0].name)}" : 'channelId'
-%>

  private void encode<%= entity.qualified_name.gsub('.','') %>( @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet<% unless in_single_graph %>, @java.lang.SuppressWarnings( "SameParameterValue" ) final int channelId<% end %>, @javax.annotation.Nonnull final java.sql.PreparedStatement statement<% if require_channelRootIdColumn %>, @java.lang.SuppressWarnings( "SameParameterValue" ) @javax.annotation.<%= in_type_graph ? 'Nullable' : 'Nonnull' %> final String channelRootIdColumn<% end %> )
    throws java.sql.SQLException
  {
    try ( var resultSet = statement.executeQuery() )
    {
      encode<%= entity.qualified_name.gsub('.','') %>( changeSet<% unless in_single_graph %>, channelId<% end %>, resultSet<% if require_channelRootIdColumn %>, channelRootIdColumn<% end %> );
    }
  }

  private void encode<%= entity.qualified_name.gsub('.','') %>( @javax.annotation.Nonnull final replicant.server.ChangeSet changeSet<% unless in_single_graph %>, final int channelId<% end %>, @javax.annotation.Nonnull final java.sql.ResultSet resultSet<% if require_channelRootIdColumn %>, @java.lang.SuppressWarnings( "SameParameterValue" ) @javax.annotation.<%= in_type_graph ? 'Nullable' : 'Nonnull' %> final String channelRootIdColumn<% end %> )
    throws java.sql.SQLException
  {
    while ( resultSet.next() )
    {
<% if in_instance_graph -%>
<% if in_type_graph -%>
      assert null != channelRootIdColumn || getSchemaMetaData().getChannelMetaData( <%= channelId %> ).isTypeGraph();
<% end -%>
      final var rootId = <%= in_type_graph ? 'null == channelRootIdColumn ? null : ' : '' %>resultSet.getInt( channelRootIdColumn );
<% end -%>
      final var attributeValues = new java.util.HashMap<String, java.io.Serializable>();
<% if has_links -%>
      @javax.annotation.Nullable final var links = new java.util.HashSet<replicant.server.ChannelLink>();
<% end -%>
<% entity.attributes.select{|a| a.imit?}.each do |attribute|
    a = attribute.reference? ? attribute.referenced_entity.primary_key : attribute
    type_suffix = 'Object'
    type_suffix = 'Int' if a.integer?
    type_suffix = 'Int' if a.imit.transport_characteristic_type_key == :enumeration && a.enumeration.numeric_values?
    type_suffix = 'Long' if a.long? && !attribute.nullable?
    type_suffix = 'Boolean' if a.boolean?
    type_suffix = 'Date' if a.date?
    type_suffix = 'Timestamp' if a.datetime?
    type_suffix = 'String' if a.text?
    type_suffix = 'String' if a.imit.transport_characteristic_type_key == :enumeration && a.enumeration.textual_values?
    type_suffix = 'Double' if a.real?

    db_type = attribute.jpa.java_type(:boundary)

    if attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.textual_values?
      db_type = 'java.lang.String'
    elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.numeric_values?
      db_type = 'java.lang.Integer'
    end

-%>
<% if attribute.primary_key? -%>
      final var entityId = resultSet.getInt( "<%= attribute.sql.column_name %>" );
<% else -%>
<%
if [:date, :datetime, :text, :integer, :enumeration, :boolean].include?(attribute.imit.transport_characteristic_type_key)
-%>
      <% unless attribute.imit.auto_graph_links.select{|graph_link| graph_link.path.nil? && !attribute.primary_key?}.empty? %>final var attribute<%= attribute.name %> = <% end -%>decode<%= attribute.nullable? ? 'Nullable' : '' %><%= type_suffix %>Attribute( resultSet, attributeValues, "<%= attribute.name %>", "<%= attribute.sql.column_name %>" );
<%
else
  Domgen.error("Unable to convert data type #{attribute.imit.transport_characteristic_type_key} on #{attribute.qualified_name}")
end -%>
<% end -%>
<% attribute.imit.auto_graph_links.each do |graph_link| -%>
<% unless in_single_graph -%>
      if ( <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph_link.source_graph) %> == <%= channelId %> )
      {
<% end -%>
<%
  instance_root = graph_link.path.nil? ? nil : repository.entity_by_name(repository.imit.graph_by_name(graph_link.target_graph).instance_root)
  source_graph = repository.imit.graph_by_name(graph_link.source_graph)
  targetId = nil
  check_column = nil
  if instance_root && attribute.nullable?
    targetId = "(java.lang.Integer) resultSet.getObject( \"#{instance_root.name}#{instance_root.primary_key.sql.column_name}\" )"
    check_column = "resultSet.findColumn( \"#{instance_root.name}#{instance_root.primary_key.sql.column_name}\" )"
  end
  if instance_root && !attribute.nullable?
    targetId = "resultSet.getInt( \"#{instance_root.name}#{instance_root.primary_key.sql.column_name}\" )"
    check_column = "resultSet.findColumn( \"#{instance_root.name}#{instance_root.primary_key.sql.column_name}\" )"
  end
  targetId = 'entityId' if instance_root.nil? && attribute.primary_key?
  targetId = "attribute#{attribute.name}" if instance_root.nil? && !attribute.primary_key?
-%>
<% if check_column -%>
<% unless in_single_graph %>  <% end %>      <%= check_column %>;
<% end -%>
<% unless in_single_graph %>  <% end %>      addChannelLink( links, <%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph_link.source_graph) %>, <%= source_graph.instance_root? ? 'rootId, ' : '' %><%= repository.imit.qualified_subscription_constants_name %>.<%= Reality::Naming.uppercase_constantize(graph_link.target_graph) %>, <%= targetId %> );
<% unless in_single_graph -%>
      }
<% end -%>
<% end -%>
<% end -%>
      changeSet.merge( new replicant.server.Change( new replicant.server.EntityMessage( entityId, <%= repository.imit.qualified_entity_type_constants_name %>.<%= Reality::Naming.uppercase_constantize(entity.data_module.name.to_s) %>_<%= Reality::Naming.uppercase_constantize(entity.name.to_s) %>, 0, new java.util.HashMap<>(), attributeValues, <%= has_links ? 'links' : 'null' %> ), <%= channelId %>, <%= in_instance_graph ? 'rootId' : 'null' %> ) );
    }
  }
<%
    end
  end
end
-%>
<% repository.data_modules.select { |data_module| data_module.imit? }.each do |data_module| -%>
<% data_module.entities.select { |entity| entity.imit?  }.each do |entity| -%>
<% if entity.concrete? -%>

  @javax.annotation.Nonnull
  java.util.Map<String, java.io.Serializable> encode<%= entity.name %>( @javax.annotation.Nonnull final <%= entity.jpa.qualified_name %> entity )
  {
    final var attributes = new java.util.HashMap<String, java.io.Serializable>();
    encode<%= entity.name %>( entity, attributes );
    return attributes;
  }
<% end -%>

  private void encode<%= entity.name %>( @javax.annotation.Nonnull final <%= entity.jpa.qualified_name %> entity, @javax.annotation.Nonnull final java.util.Map<String, java.io.Serializable> attributes )
  {
<% if entity.extends
   other = entity.data_module.entity_by_name(entity.extends) -%>
    encode<%= other.name %>( entity, attributes );
<% end -%>
<% entity.declared_attributes.select{|attribute| attribute.imit? && !attribute.abstract? }.each do |attribute|
    characteristic_type_key = attribute.imit.transport_characteristic_type_key
    requires_var = attribute.nullable? && ([:datetime, :date, :enumeration].include?(characteristic_type_key) || attribute.reference?)
    accessor = "entity.#{getter_for(attribute)}"
    varname = "$#{attribute.name}"
    value = requires_var ? varname : accessor
    transformed_data =
        if characteristic_type_key == :datetime
          "#{value}.getTime()"
        elsif characteristic_type_key == :date
          "toDateString( #{value} )"
        elsif attribute.reference?
          "#{value}.#{getter_for(attribute.referenced_entity.primary_key)}"
        elsif characteristic_type_key == :enumeration && attribute.enumeration.textual_values?
          "#{value}.name()"
        elsif characteristic_type_key == :enumeration && attribute.enumeration.numeric_values?
          "#{value}.ordinal()"
        else
          value
        end
-%>
<% unless attribute.primary_key? -%>
<% if requires_var -%>
    final var <%= varname %> = <%= accessor %>;
<% end -%>
    attributes.put( "<%= attribute.name %>", <%= transformed_data != value && attribute.nullable? ? "null == #{varname} ? null : #{transformed_data}" : transformed_data %> );
<% end -%>
<% end -%>
  }
<% end -%>
<% end -%>}
