/* DO NOT EDIT: File is auto-generated */
package <%= repository.imit.entity_package %>;

import org.realityforge.replicant.client.transport.SubscriptionEntry;

public class <%= repository.imit.client_session_name %>
  extends org.realityforge.replicant.client.transport.ClientSession<<%= repository.imit.qualified_graph_enum_name %>>
  implements <%= repository.imit.qualified_client_session_interface_name %>
{
  private static final java.util.logging.Logger LOG = java.util.logging.Logger.getLogger( <%= repository.imit.client_session_name %>.class.getName() );

  private final <%= repository.imit.qualified_client_session_context_name %> _context;

  public <%= repository.imit.client_session_name %>( @javax.annotation.Nonnull final String sessionID, @javax.annotation.Nonnull final <%= repository.imit.qualified_client_session_context_name %> context )
  {
    super( sessionID );
    _context = context;
  }

<%
  repository.imit.graphs.each do |graph|
  param = ''
  param_value = ''
  param_early_value = ''
  param_cache_value = ''
  subscribe_method = 'Type'
  if graph.instance_root?
    # Names are fully qualified so take any random data module
    entity = repository.entity_by_name(graph.instance_root)
    type = entity.primary_key.imit.primitive_java_type
    varname = "#{Domgen::Naming.camelize(entity.name)}#{entity.primary_key.name}"
    param = "final #{type} #{varname}"
    param_value = ", #{varname}"
    param_early_value = varname
    subscribe_method = 'Instance'
  elsif graph.cacheable?
    param_cache_value = 'eTag, cacheCurrentAction, '
  end
  filter_param = ''
  update_param = param.dup
  update_param_early_value = param_early_value.dup
  if graph.filter_parameter
    p = graph.filter_parameter
    java_type = "#{nullability_annotation(p.nullable?)} #{Domgen::Java.java_type(p, :imit, :default)}"
    update_param = "#{update_param}, " if update_param.size > 0
    filter_param = "#{java_type} filter"
    update_param = "#{update_param}#{filter_param}"
    update_param_early_value = "#{update_param_early_value}, " if update_param_early_value.size > 0
    update_param_early_value = "#{update_param_early_value}filter"
  end
  suffix = "@javax.annotation.Nullable final Runnable action"
%>
  @Override
  public boolean isSubscribedTo<%= graph.name %>(<%= param %>)
  {
    return null != find<%= subscribe_method %>GraphSubscription( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.name) %><%= param_value %> );
  }

<% if graph.instance_root? -%>
  @Override
  public java.util.Map<Object, SubscriptionEntry<<%= repository.imit.qualified_graph_enum_name %>>> get<%= graph.name %>Subscriptions()
  {
    final java.util.Map<Object, SubscriptionEntry<<%= repository.imit.qualified_graph_enum_name %>>> subscriptions =
      getInstanceSubscriptions().get( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.name) %> );
    if ( null != subscriptions )
    {
      return java.util.Collections.unmodifiableMap( subscriptions );
    }
    else
    {
      return java.util.Collections.emptyMap();
    }
  }
<% end -%>

  @Override
  public void subscribeTo<%= graph.name %>(<%= update_param %><%= update_param.size > 0 ? ", #{suffix}" : suffix %>)
  {
    final SubscriptionEntry<<%= repository.imit.qualified_graph_enum_name %>> entry =
      subscribeTo<%= subscribe_method %>Graph( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.name) %><%= param_value %> );
    if( null != entry )
    {
      final Runnable runnable = new Runnable()
      {
        @Override
        public void run()
        {
          entry.markAsPresent();
          LOG.info( "subscribeTo<%= graph.name %>(<%= graph.instance_root? ? "\" + #{varname} + \"" : "" %>) completed." );
          if( null != action )
          {
            action.run();
          }
        }
      };
<% if graph.cacheable? -%>
      final org.realityforge.replicant.client.transport.CacheEntry cacheEntry = _context.getCacheService().lookup( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.name) %>.name() );
      final String eTag = null != cacheEntry ? cacheEntry.getETag() : null;
      final String content = null != cacheEntry ? cacheEntry.getContent() : null;
      if( null != content )
      {
        LOG.info( "Found locally cached data for graph <%= graph.name %> with etag " + eTag + "." );
      }
      final Runnable cacheCurrentAction = new Runnable()
      {
        public void run()
        {
          assert null != content;
          LOG.info( "Loading cached data for graph <%= graph.name %> with etag " + eTag );
          //TODO: Figure out how to make the bulkLoad configurable
          _context.loadCachedContent( content, runnable, true );
        }
      };
<% end -%>
      LOG.info( "subscribeTo<%= graph.name %>(<%= graph.instance_root? ? "\" + #{varname} + \"" : "" %>) requested." );
      _context.remoteSubscribeTo<%= graph.name %>( <%= param_cache_value %><%= update_param_early_value %><%= update_param_early_value.size > 0 ? ', ' : '' %>runnable );
    }
<% if graph.filter_parameter -%>
    else
    {
      update<%= graph.name %>Subscription(<%= update_param_early_value %><%= update_param_early_value.size > 0 ? ', ' : '' %>action);
    }
<% end -%>
  }

<% if graph.filter_parameter %>
  public void update<%= graph.name %>Subscription(<%= update_param %><%= update_param.size > 0 ? ", #{suffix}" : suffix %>)
  {
    final SubscriptionEntry<<%= repository.imit.qualified_graph_enum_name %>> entry =
      find<%= subscribe_method %>GraphSubscription( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.name) %><%= param_value %> );
    if( null != entry )
    {
      final Runnable runnable = new Runnable()
      {
        @Override
        public void run()
        {
          entry.setSubscriptionUpdateInProgress( false );
          LOG.info( "update<%= graph.name %>Subscription(<%= graph.instance_root? ? "\" + #{varname} + \"" : "" %>) completed." );
          if( null != action )
          {
            action.run();
          }
        }
      };
      LOG.info( "update<%= graph.name %>Subscription(<%= graph.instance_root? ? "\" + #{varname} + \"" : "" %>) requested." );
      entry.setSubscriptionData( filter );
      entry.setSubscriptionUpdateInProgress( true );
      _context.remoteUpdate<%= graph.name %>Subscription( <%= update_param_early_value %><%= update_param_early_value.size > 0 ? ', ' : '' %>runnable );
    }
    else
    {
      LOG.warning( "update<%= graph.name %>Subscription(<%= graph.instance_root? ? "\" + #{varname} + \"" : "" %>) request but not currently subscribed." );
    }
  }
<% end %>

  @Override
  public void unsubscribeFrom<%= graph.name %>(<%= param %><%= param.size > 0 ? ", #{suffix}" : suffix %>)
  {
    final SubscriptionEntry<<%= repository.imit.qualified_graph_enum_name %>> entry =
      unsubscribeFrom<%= subscribe_method %>Graph( <%= repository.imit.qualified_graph_enum_name %>.<%= Domgen::Naming.uppercase_constantize(graph.name) %><%= param_value %> );
    if( null != entry )
    {
      LOG.info( "unsubscribeFrom<%= graph.name %>(<%= graph.instance_root? ? "\" + #{varname} + \"" : "" %>) requested." );
      entry.markDeregisterInProgress();
      _context.remoteUnsubscribeFrom<%= graph.name %>( <%= param_early_value %><%= param_early_value.size > 0 ? ', ' : '' %>new Runnable()
      {
        @Override
        public void run()
        {
          entry.markAsDeregistered();
<% if !graph.instance_root? -%>
          unload<%= graph.name %>();
<%
  else
    entity = repository.entity_by_name(graph.instance_root)
%>
          final <%= entity.imit.qualified_name %> e = _context.getRepository().findByID( <%= entity.imit.qualified_name %>.class, <%= varname %> );
          if( null != e )
          {
            unload<%= graph.name %>_<%= entity.name %>( e );
          }
<% end %>
          LOG.info( "unsubscribeFrom<%= graph.name %>(<%= graph.instance_root? ? "\" + #{varname} + \"" : "" %>) completed." );
          if( null != action )
          {
            action.run();
          }
        }
      } );
    }
    else
    {
      LOG.info( "unsubscribeFrom<%= graph.name %>(<%= graph.instance_root? ? "\" + #{varname} + \"" : "" %>) requested but no such subscription." );
      if( null != action )
      {
        action.run();
      }
    }
  }

<% if !graph.instance_root? -%>
  @Override
  public void unload<%= graph.name %>()
  {
    _context.getEntityChangeBroker().pause();
<%
  graph.type_roots.reverse.each do |root|
    entity = repository.entity_by_name(root)
-%>
    for ( final <%= entity.imit.qualified_name %> e : _context.getRepository().findAll( <%= entity.imit.qualified_name %>.class ) )
    {
      _context.getRepository().deregisterEntity( <%= entity.imit.qualified_name %>.class, e.get<%= entity.primary_key.name %>() );
    }
<% end -%>
    _context.getEntityChangeBroker().resume();
  }
<% else %>
<%
  graph.reachable_entities.collect{|n|repository.entity_by_name(n)}.select { |entity| entity.imit? && !entity.abstract? }.each do |entity|
    is_root = entity.qualified_name.to_s == graph.instance_root.to_s
    outgoing_links = entity.referencing_attributes.select{|a| a.imit? && a.imit.client_side? && a.inverse.imit.traversable? && a.inverse.imit.replication_edges.include?(graph.name)}
-%>
<% if is_root -%>
  @Override
  public void unload<%= graph.name %>(@javax.annotation.Nonnull final <%= entity.imit.qualified_name %> object )
  {
    unload<%= graph.name %>_<%= entity.name %>( object );
  }
<% end -%>
  <%= is_root ? "protected" : "private" %> void unload<%= graph.name %>_<%= entity.name %>(@javax.annotation.Nonnull final <%= entity.imit.qualified_name %> object )
  {
<% if is_root -%>
    _context.getEntityChangeBroker().pause();
<% end -%>
<%
    outgoing_links.each do |a|
      if a.inverse.multiplicity == :many
-%>
    for ( final <%= a.entity.imit.qualified_name %> o : new java.util.ArrayList<<%= a.entity.imit.qualified_name %>>(object.get<%= Domgen::Naming.pluralize(a.inverse.name) %>()) )
    {
      unload<%= graph.name %>_<%= a.entity.name %>( o );
    }
<%
      elsif a.inverse.multiplicity == :one || a.inverse.multiplicity == :zero_or_one
-%>
      {
        final <%= a.entity.imit.qualified_name %> o = object.get<%= a.inverse.name %>();
        <% if a.inverse.multiplicity == :zero_or_one %>if( null != o )<% end %>
        {
          unload<%= graph.name %>_<%= a.entity.name %>( o );
        }
      }
<%
      end
    end
    entity.attributes.each do |a|
      if a.reference? && a.imit? && a.inverse.imit.traversable? && a.imit.client_side? && a.referenced_entity.imit? && a.imit.include_edges.include?(graph.name)
        # These are likely to be shared so we have to be careful and check if they are part of other subscriptions?
        if a.imit.traverse_during_unload?
%>
      {
        final <%= a.referenced_entity.imit.qualified_name %> o = object.get<%= a.name %>();
        <% if a.nullable? %>if( null != o )<% end %>
        {
          unload<%= graph.name %>_<%= a.referenced_entity.name %>( o );
        }
      }
<%
        end
      end
    end
    if entity.qualified_name.to_s != graph.instance_root.to_s || entity.imit.replication_graphs.size == 1
     # We should really check to see if they have shared subscriptions
 %>
    _context.getRepository().deregisterEntity( <%= entity.imit.qualified_name %>.class, object.get<%= entity.primary_key.name %>() );
<% end -%>
<% if is_root -%>
    _context.getEntityChangeBroker().resume();
<% end -%>
  }
<% end %>
<% end %>

<% end %>
}
